/*
 * cpp_source_stream.cpp
 *
 *  Created on: May 13, 2016
 *      Author: zmij
 */

#include <wire/wire2cpp/cpp_source_stream.hpp>
#include <sstream>

namespace wire {
namespace idl {
namespace cpp {

namespace fs = ::boost::filesystem;

namespace {

::std::string const autogenerated =
R"~(/*
 * THIS FILE IS AUTOGENERATED BY wire2cpp PROGRAM
 * Any manual modifications can be lost
 */
)~";

::std::string
create_header_guard(fs::path const& inc_dir, fs::path const& fname)
{
    ::std::ostringstream os;
    os << "_";
    for (auto const& p : inc_dir) {
        os << p.string() << "_";
    }
    os << fname.stem().string() << "_HPP_";

    auto hg = os.str();
    ::std::transform(hg.begin(), hg.end(),
            hg.begin(), toupper);

    return hg;
}

}  /* namespace  */

source_stream::source_stream(path const& origin_path, path const& header_dir,
        string_list const& include_dirs)
    : header_dir_{header_dir},
      is_header_{false}
{
    for (auto const& inc : include_dirs) {
        path inc_path{inc};
        if (inc_path.is_relative() && fs::exists(inc_path)) {
            inc_path = fs::canonical(inc_path);
        }
        if (fs::exists(inc_path)) {
            include_dirs_.push_back(inc_path.string());
        }
    }
}

source_stream::~source_stream()
{
    if (is_header_) {
        stream_ << "#endif          /* " << header_guard_ << " */\n";
    }
}

void
source_stream::open(path const& p)
{
    stream_.open(p.string());
    stream_ << autogenerated;
    if (p.extension() == ".hpp") {
        is_header_ = true;
        header_guard_ = create_header_guard(header_dir_, p.filename());

        stream_ << "#ifndef " << header_guard_ << "\n"
                << "#define " << header_guard_ << "\n\n";
    } else {
        // include header
        path head = p.stem();
        head += ::std::string{".hpp"};
        include(head);
    }
}

source_stream&
source_stream::include(::std::string const& include_str)
{
    stream_ << "#include " << include_str << "\n";
    return *this;
}

source_stream&
source_stream::include(path inc_file)
{
    if (inc_file.extension() == ".wire") {
        ::std::cerr << "Include wire file " << inc_file.string() << "\n";
        inc_file.replace_extension(".hpp");
    } else {
        ::std::cerr << "Include header " << inc_file.string() << "\n";
    }
    if (inc_file.is_relative() && !inc_file.has_parent_path()) {
        if (!header_dir_.empty()) {
            include(header_dir_ / inc_file.filename());
        } else {
            stream_ << "#include \"" << inc_file.string() << "\"\n";
        }
    } else if (!inc_file.is_relative()) {
        // Absolute path, as preprocessor feeds
        auto file_path = inc_file.string();
        auto orig = origin_path_.string();
        if (file_path.find(orig) == 0) {
            // Same directory or below
            path p { file_path.substr(orig.size() + 1) };
            if (!header_dir_.empty()) {
                include(header_dir_ / p);
            } else{
                include(p);
            }
        } else {
            // Include from one of include directories
            for (auto const& inc_dir : include_dirs_) {
                if (file_path.find(inc_dir) == 0) {
                    path p { file_path.substr(inc_dir.size() + 1) };
                    include(p);
                    break;
                }
            }
        }
    } else {
        // Relative path with parent path
        stream_ << "#include <" << inc_file.string() << ">\n";
    }
    return *this;
}


}  /* namespace cpp */
}  /* namespace idl */
}  /* namespace wire */
