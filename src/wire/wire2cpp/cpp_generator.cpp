/*
 * cpp_generator.cpp
 *
 *  Created on: 27 апр. 2016 г.
 *      Author: sergey.fedorov
 */

#include <wire/wire2cpp/cpp_generator.hpp>

#include <iostream>
#include <sstream>
#include <iomanip>
#include <cctype>
#include <algorithm>
#include <boost/filesystem.hpp>

#include <wire/idl/syntax_error.hpp>
#include <wire/util/murmur_hash.hpp>

namespace wire {
namespace idl {
namespace cpp {

namespace {

::std::string const autogenerated =
R"~(/*
 * THIS FILE IS AUTOGENERATED BY wire2cpp PROGRAM
 * Any manual modifications can be lost
 */
)~";

struct type_mapping {
    ::std::string                     type_name;
    ::std::vector<::std::string>      headers;
};

::std::map< ::std::string, type_mapping > const wire_to_cpp = {
    /* Wire type      C++ Type                  Headers                                      */
    /*--------------+-------------------------+----------------------------------------------*/
    { "void",       { "void",                   {}                                          } },
    { "bool",       { "bool",                   {}                                          } },
    { "char",       { "char",                   {}                                          } },
    { "byte",       { "::std::int8_t",          {"<cstdint>"}                               } },
    { "int32",      { "::std::int32_t",         {"<cstdint>"}                               } },
    { "int64",      { "::std::int64_t",         {"<cstdint>"}                               } },
    { "octet",      { "::std::uint8_t",         {"<cstdint>"}                               } },
    { "uint32",     { "::std::int32_t",         {"<cstdint>"}                               } },
    { "uint64",     { "::std::int64_t",         {"<cstdint>"}                               } },
    { "float",      { "float",                  {}                                          } },
    { "double",     { "double",                 {}                                          } },
    { "string",     { "::std::string",          {"<string>"}                                } },
    { "uuid",       { "::boost::uuids::uuid",   {"<boost/uuid/uuid.hpp>",
                                                "<wire/encoding/detail/uuid_io.hpp>"}       } },

    { "variant",    { "::boost::variant",       {"<boost/variant.hpp>",
                                                "<wire/encoding/detail/variant_io.hpp>"}    } },
    { "optional",   { "::boost::optional",      {"<boost/optional.hpp>",
                                                "<wire/encoding/detail/optional_io.hpp>"}   } },
    { "sequence",   { "::std::vector",          {"<vector>",
                                                "<wire/encoding/detail/containers_io.hpp>"} } },
    { "array",      { "::std::array",           {"<array>",
                                                "<wire/encoding/detail/containers_io.hpp>"} } },
    { "dictionary", { "::std::map",             {"<map>",
                                                "<wire/encoding/detail/containers_io.hpp>"} } },

};

::std::size_t tab_width = 4;

void
strip_quotes(::std::string& str)
{
    if (!str.empty() && str.front() == '"') {
        str.erase(str.begin());
    }
    if (!str.empty() && str.back() == '"') {
        str.erase(--str.end());
    }
}

}  /* namespace  */

::std::ostream&
operator << (::std::ostream& os, offset const& val)
{
    ::std::ostream::sentry s(os);
    if (s) {
        os << "\n";
        for (size_t i = 0; i < val.sz * tab_width; ++i) {
            os << " ";
        }
    }
    return os;
}


namespace fs = ::boost::filesystem;

generator::generator(generate_options const& opts, preprocess_options const& ppo,
        ast::global_namespace_ptr ns)
    : ns_{ns}, unit_{ns->current_compilation_unit()},
      current_scope_{true}
{
    auto cwd = fs::current_path();

    fs::path origin(unit_->name);
    fs::path header_path{ opts.header_output_dir };
    fs::path source_path{ opts.source_output_dir };

    ::std::string origin_path = origin.parent_path().string();

    if (header_path.empty()) {
        header_path = fs::current_path();
    }
    if (header_path.is_relative()) {
        header_path = fs::absolute(header_path);
    }
    if (!fs::exists(header_path)) {
        fs::create_directories(header_path);
    }
    header_path = fs::canonical(header_path);

    header_path /= origin.filename().stem().string() + ".hpp";

    if (source_path.empty()) {
        source_path = fs::current_path();
    }
    if (source_path.is_relative()) {
        source_path = fs::absolute(source_path);
    }
    if (!fs::exists(source_path)) {
        fs::create_directories(source_path);
    }
    source_path = fs::canonical(source_path);

    source_path /= origin.filename().stem().string() + ".cpp";

    string_list includes_rooted;

    for (auto const& inc : ppo.include_dirs) {
        fs::path in_path(inc);
        if (in_path.is_relative() && fs::exists(in_path)) {
            in_path = fs::canonical(in_path);
        }
        if (fs::exists(in_path)) {
            includes_rooted.push_back(in_path.string());
        }
    }

    header_guard_ = "_" + opts.header_include_dir + "_" +
            origin.stem().string() + "_HPP_";
    ::std::transform(header_guard_.begin(), header_guard_.end(),
            header_guard_.begin(), toupper);

    header_.open(header_path.string());
    source_.open(source_path.string());
    header_ << autogenerated
            << "#ifndef " << header_guard_ << "\n"
            "#define " << header_guard_ << "\n\n";
    source_ << autogenerated;

    if (!opts.header_include_dir.empty()) {
        source_ << "#include <" << opts.header_include_dir << "/"
                << origin.stem().string() << ".hpp>\n";
    } else {
        source_ << "#include \"" << origin.stem().string() << ".hpp\"\n";
    }

    //------------------------------------------------------------------------
    ::std::set< ::std::string > standard_headers {"<memory>"};
    auto deps = unit_->external_dependencies();
    for (auto const& d : deps) {
        if (auto t = ast::dynamic_entity_cast< ast::type >(d)) {
            if (ast::type::is_built_in(d->get_qualified_name())) {
                auto const& tm = wire_to_cpp.at(d->name());
                if (!tm.headers.empty()) {
                    standard_headers.insert(tm.headers.begin(), tm.headers.end());
                }
            }
        }
    }

    // Collect custom headers and types from type aliases
    ast::entity_const_set type_aliases;
    for (auto const& e : unit_->entities) {
        e->collect_elements(type_aliases,
        [](ast::entity_const_ptr e){
            return ast::dynamic_entity_cast< ast::type_alias >(e).get();
        });
    }

    for (auto ta : type_aliases) {
        auto const& anns = ta->get_annotations();
        auto f = find(anns, annotations::CPP_CONTAINER);
        if (f != anns.end()) {
            if (f->arguments.size() < 2)
                throw grammar_error(ta->decl_position(),
                        "Invalid cpp_container annotation");
            ::std::string header = f->arguments[1]->name;
            strip_quotes(header);
            standard_headers.insert(header);
        }
    }

    for (auto const& hdr : standard_headers) {
        header_ << "#include " << hdr << "\n";
    }
    header_ << "#include <wire/encoding/wire_io.hpp>\n";
    //------------------------------------------------------------------------
    auto units = unit_->dependent_units();
    for (auto const& u : units) {

        if (!u->is_builtin()) {
            fs::path fp(u->name);
            if (fp.is_relative() && !fp.has_parent_path()) {
                ::std::cerr << "\t" << u->name << "\n";
                if (!opts.header_include_dir.empty()) {
                    header_ << "#include <" << opts.header_include_dir << "/"
                            << fp.stem().string() << ".hpp>\n";
                } else {
                    header_ << "#include \"" << fp.stem().string() << ".hpp\"\n";
                }
            } else  if (u->name.find(origin_path) == 0) {
                // Same directory
                ::std::cerr << "\t" << u->name.substr(origin_path.size() + 1) << "\n";
                if (!opts.header_include_dir.empty()) {
                    header_ << "#include <" << opts.header_include_dir << "/"
                            << fp.stem().string() << ".hpp>\n";
                } else {
                    header_ << "#include \"" << fp.stem().string() << ".hpp\"\n";
                }
            } else {
                // Try to cut off the include root or current
                for (auto const& inc : includes_rooted) {
                    if (u->name.find(inc) == 0) {
                        fs::path ipath{u->name.substr(inc.size() + 1)};
                        ::std::cerr << "\t" << ipath << "\n";
                        header_ << "#include <" << ipath.parent_path().string() << "/"
                                << ipath.stem().string() << ".hpp>\n";
                        break;
                    }
                }
            }
        }
    }

    header_ << "#include <wire/errors/user_exception.hpp>\n";
    header_ << "#include <wire/core/object.hpp>\n";
    header_ << "#include <wire/core/callbacks.hpp>\n";

    source_ << "#include <wire/core/dispatch_request.hpp>\n";
    source_ << "#include <unordered_map>\n";

    header_ << "\n";
    source_ << "\n";
}

generator::~generator()
{
    adjust_scope(qname{}.search());
    header_ << "\n#endif /* " << header_guard_ << " */\n";
}

void generator::adjust_scope(ast::entity_ptr enum_)
{
    auto qn = enum_->get_qualified_name();
    adjust_scope(qn.search().scope());
}

void
generator::adjust_scope(qname_search const& target)
{
    qname_search current = current_scope_.search();

    auto c = current.begin;
    auto t = target.begin;
    for (; c != current.end && t != target.end && *c == *t; ++c, ++t);

    auto erase_start = c;
    ::std::deque<::std::string> to_close;
    for (; c != current.end; ++c) {
        to_close.push_front(*c);
    }
    for (auto const& ns : to_close) {
        header_ << h_off_ << "} /* namespace " << ns << " */";
        source_ << s_off_ << "} /* namespace " << ns << " */";
    }

    if (!to_close.empty()) {
        header_ << "\n";
        source_ << "\n";
    }


    current_scope_.components.erase(erase_start, current_scope_.components.end());

    bool space = t != target.end;
    for (; t != target.end; ++t) {
        header_ << h_off_ << "namespace " << *t << " {";
        source_ << s_off_ << "namespace " << *t << " {";
        current_scope_.components.push_back(*t);
    }
    if (space) {
        header_ << "\n";
        source_ << "\n";
    }
}

void
generator::pop_scope() {
    scope_stack_.pop_back();
    if (scope_stack_.empty()) {
        for (auto f : free_functions_) {
            f();
        }
        free_functions_.clear();
    }
}

::std::string
generator::constant_prefix(qname const& qn) const
{
    ::std::ostringstream os;
    for (auto c : qn.components) {
        ::std::transform(c.begin(), c.end(), c.begin(), toupper);
        os << c << "_";
    }
    return os.str();
}

::std::ostream&
generator::write_qualified_name(::std::ostream& os, qname const& qn)
{
    qname_search current = current_scope_.search();
    qname_search target = qn.search();

    auto c = current.begin;

    for (; c != current.end && !target.empty() && *c == *target.begin;
            ++c, ++target);

    if (target.empty()) {
        os << qn;
    } else {
        os << target;
    }

    return os;
}

::std::ostream&
generator::write_type_name(::std::ostream& os, ast::type_const_ptr t,
        grammar::annotation_list const& annotations)
{
    if (auto pt = ast::dynamic_entity_cast< ast::parametrized_type >(t)) {
        ::std::string tmpl_name = wire_to_cpp.at(pt->name()).type_name;
        if (pt->name() == ast::ARRAY || pt->name() == ast::SEQUENCE || pt->name() == ast::DICTONARY) {
            auto ann = find(annotations, annotations::CPP_CONTAINER);
            if (ann != annotations.end()) {
                if (ann->arguments.empty()) {
                    throw grammar_error(t->decl_position(), "Invalid cpp_container annotation");
                }
                tmpl_name = ann->arguments.front()->name;
                strip_quotes(tmpl_name);
            }
        }
        os << tmpl_name << " <";
        for (auto p = pt->params().begin(); p != pt->params().end(); ++p) {
            if (p != pt->params().begin())
                os << ", ";
            switch (p->which()) {
                case ast::template_param_type::type:
                    write_type_name(os, ::boost::get< ast::type_ptr >(*p) );
                    break;
                case ast::template_param_type::integral:
                    os << ::boost::get< ::std::string >(*p);
                    break;
                default:
                    throw grammar_error(t->decl_position(),
                            "Unknown template parameter kind");
            }
        }
        os << ">";
    } else {
        if (ast::type::is_built_in(t->get_qualified_name())) {
            os << wire_to_cpp.at(t->name()).type_name;
        } else if (auto ref = ast::dynamic_entity_cast< ast::reference >(t)) {
            write_qualified_name(os, t->get_qualified_name()) << "_prx";
        } else if (auto cl = ast::dynamic_type_cast< ast::class_ >(t)) {
            write_qualified_name(os, t->get_qualified_name()) << "_ptr";
        } else if (auto iface = ast::dynamic_type_cast< ast::interface >(t)) {
            write_qualified_name(os, t->get_qualified_name()) << "_ptr";
        } else {
            write_qualified_name(os, t->get_qualified_name());
        }
    }
    return os;
}

::std::ostream&
generator::write_arg_type(::std::ostream& os, ast::type_const_ptr t,
        grammar::annotation_list const& annotations)
{
    write_type_name(os, t, annotations);
    if (!ast::type::is_built_in(t->get_qualified_name())) {
        // TODO Check if it is a ptr to a class or a ptr or a proxy to an interface
        os << " const&";
    } else if (t->name() == "string" || t->name() == "uuid") {
        os << " const&";
    }
    return os;
}

::std::ostream&
generator::write_init(::std::ostream& os, offset& off, grammar::data_initializer const& init)
{
    switch (init.value.which()) {
        case 0: {
            os << ::boost::get< ::std::string >(init.value);
            break;
        }
        case 1: {
            grammar::data_initializer::initializer_list const& list =
                    ::boost::get<grammar::data_initializer::initializer_list>(init.value);
            if (list.size() < 3) {
                os << "{";
                for (auto p = list.begin(); p != list.end(); ++p) {
                    if (p != list.begin())
                        os << ", ";
                    write_init(os, off, *(*p));
                }
                os << "}";
            } else {
                os << "{" << ++off;
                for (auto p = list.begin(); p != list.end(); ++p) {
                    if (p != list.begin())
                        os << "," << off;
                    write_init(os, off, *(*p));
                }
                os << --off << "}";
            }
            break;
        }
    }
    return os;
}

::std::ostream&
generator::write_data_member(::std::ostream& os, offset const& off, ast::variable_ptr var)
{
    os << off;
    write_type_name(header_, var->get_type(), var->get_annotations())
        << " " << var->name() << ";";
    return os;
}

void
generator::generate_dispatch_function_member(ast::function_ptr func)
{
    offset_guard hdr{h_off_};
    offset_guard src{s_off_};

    auto ann = find(func->get_annotations(), ast::annotations::SYNC);
    bool async_dispatch = ann == func->get_annotations().end();
    auto const& params = func->get_params();

    ::std::ostringstream formal_params;
    for (auto const& p : params) {
        write_arg_type(formal_params, p.first) << " " << p.second << ", ";
    }

    if (async_dispatch) {
        ::std::ostringstream ret_cb_name;
        if (!func->is_void()) {
            ret_cb_name << func->name() << "_return_callback";
            header_ << h_off_ << "using " << ret_cb_name.str() << " = "
                << "::std::function< void(";
            write_arg_type(header_, func->get_return_type(), func->get_annotations())
                << ") >;";
        } else {
            ret_cb_name << "::wire::core::callbacks::void_callback";
        }

        header_ << h_off_ << "/* Async dispatch */"
                << h_off_ << "virtual void"
                << h_off_ << func->name() << "(" << formal_params.str()
                << ret_cb_name.str() << ", "
                << "::wire::core::current const& = ::wire::core::no_current) = 0;";
    } else {
        header_ << h_off_ << "/* Sync dispatch */"
                << h_off_ << "virtual ";
        write_type_name(header_, func->get_return_type(), func->get_annotations())
                << h_off_ << func->name() << "(" << formal_params.str()
                << "::wire::core::current const& = ::wire::core::no_current) = 0;";
    }
    header_ << h_off_ << "void"
            << h_off_ << "__" << func->name()
            << "(::wire::core::dispatch_request const&, ::wire::core::current const&);\n";

    current_scope_.components.pop_back();

    source_ << s_off_ << "void"
            << s_off_ << func->owner()->name() << "::__" << func->name()
            << "(::wire::core::dispatch_request const& __req, ::wire::core::current const& __curr)"
            << s_off_ << "{";

    ++s_off_;
    // Unmarshal params
    ::std::ostringstream call_params;
    if (!params.empty()) {
        source_ << s_off_ << "auto __beg = __req.encaps_start;"
                << s_off_ << "auto __end = __req.encaps_end;";
        for (auto p = params.begin(); p != params.end(); ++p) {
            source_ << s_off_;
            write_type_name(source_, p->first) << " " << p->second << ";";
            if (p != params.begin())
                call_params << ", ";
            call_params << p->second;
        }
        source_ << s_off_ << "::wire::encoding::read(__beg, __end, " << call_params.str() << ");";
    }

    ::std::ostringstream fcall;
    fcall << func->name() << "(" << call_params.str();
    if (!params.empty())
        fcall << ", ";
    if (async_dispatch) {
        // Generate callback
        source_ << s_off_ << fcall.str();
        source_ << ++s_off_ << "[__req](";
        if (!func->is_void()) {
            write_arg_type(source_, func->get_return_type(), func->get_annotations())
                    << " _res";
        }
        source_ << ")"
                << s_off_++ << "{";
        source_ << s_off_ << "::wire::encoding::outgoing __out;";
        if (!func->is_void()) {
            source_ << s_off_
                    << "::wire::encoding::write(::std::back_inserter(__out), _res);";
        }
        source_ << s_off_ << "__req.result(::std::move(__out));";
        source_ << --s_off_ << "}, __curr);";
        --s_off_;
    } else {
        fcall << "__curr)";
        source_ << s_off_ << "::wire::encoding::outgoing __out;";
        if (func->is_void()) {
            source_ << s_off_ << fcall.str() << ";";
        } else {
            source_ << s_off_ << "::wire::encoding::write(::std::back_inserter(__out), "
                    << fcall.str() << ");";
        }
        source_ << s_off_ << "__req.result(::std::move(__out));";
    }

    source_ << --s_off_ << "}\n";

    current_scope_.components.push_back(func->owner()->name());
}


void
generator::generate_constant(ast::constant_ptr c)
{
    adjust_scope(c);

    header_ << h_off_;
    write_type_name(header_, c->get_type()) << " const " << c->name() << " = ";
    write_init(header_, h_off_, c->get_init());
    header_ << ";";
}

void
generator::generate_enum(ast::enumeration_ptr enum_)
{
    adjust_scope(enum_);
    header_ << h_off_++ << "enum ";
    if (enum_->constrained())
        header_ << "class ";
    write_type_name(header_, enum_) << "{";
    for (auto e : enum_->get_enumerators()) {
        header_ << h_off_ << e.first;
        if (e.second.is_initialized()) {
            header_ << " = " << *e.second;
        }
        header_ << ",";
    }
    header_ << --h_off_ << "};\n";
}

void
generator::generate_type_alias( ast::type_alias_ptr ta )
{
    adjust_scope(ta);

    header_ << h_off_ << "using " << ta->name() << " = ";
    // TODO Custom mapping
    write_type_name(header_, ta->alias(), ta->get_annotations());
    header_ << ";";
}

void
generator::generate_struct( ast::structure_ptr struct_ )
{
    adjust_scope(struct_);

    header_ << h_off_++ << "struct " << struct_->name() << " {";
    current_scope_.components.push_back(struct_->name());
    scope_stack_.push_back(struct_);

    for (auto t : struct_->get_types()) {
        generate_type_decl(t);
    }

    for (auto c : struct_->get_constants()) {
        generate_constant(c);
    }

    auto const& dm = struct_->get_data_members();
    for (auto d : dm) {
        write_data_member(header_, h_off_, d);
    }

    if (!dm.empty()) {
        header_ << "\n" << h_off_ << "void"
                << h_off_ << "swap(" << struct_->name() << "& rhs)"
                << h_off_ << "{";

        header_ << ++h_off_ << "using ::std::swap;";
        for (auto d : dm) {
            header_ << h_off_ << "swap(" << d->name() << ", rhs." << d->name() << ");";
        }
        header_ << --h_off_ << "}";
    }

    header_ << --h_off_ << "};\n";
    current_scope_.components.pop_back();

    pop_scope();
    if (!dm.empty()) {
        if (scope_stack_.empty()) {
            generate_read_write(struct_);
        } else {
            free_functions_.push_back(
                    ::std::bind(&generator::generate_read_write, this, struct_));
        }
    }
}

void
generator::generate_read_write( ast::structure_ptr struct_)
{
    auto const& dm = struct_->get_data_members();
    header_ << h_off_ << "template < typename OutputIterator >"
            << h_off_ << "void"
            << h_off_ << "wire_write(OutputIterator o, ";
    write_type_name(header_, struct_) << " const& v)"
            << h_off_ << "{";

    header_ << ++h_off_ << "::wire::encoding::write(o";
    for (auto d : dm) {
        header_ << ", v." << d->name();
    }
    header_ << ");";
    header_ << --h_off_ << "}\n";

    header_ << h_off_ << "template < typename InputIterator >"
            << h_off_ << "void"
            << h_off_ << "wire_read(InputIterator& begin, InputIterator end, ";
    write_type_name(header_, struct_) << "& v)"
            << h_off_ << "{";

    header_ << ++h_off_;
    write_type_name(header_, struct_) << " tmp;"
            << h_off_ << "::wire::encoding::read(begin, end";
    for (auto d : dm) {
        header_ << ", v." << d->name();
    }
    header_ << ");"
            << h_off_ << "v.swap(tmp);";
    header_ << --h_off_ << "}\n";
}

::std::string
generator::generate_type_id_funcs(ast::entity_ptr elem)
{
    offset_guard hdr{h_off_};
    offset_guard src{s_off_};

    header_ << h_off_ << "static constexpr ::std::string const&"
            << h_off_ << "wire_static_type_id();";

    header_ << h_off_ << "static constexpr ::std::uint64_t"
            << h_off_ << "wire_static_type_id_hash();";

    current_scope_.components.pop_back();
    // Source
    auto eqn = elem->get_qualified_name();
    auto pfx = constant_prefix(eqn);
    ::std::ostringstream qnos;
    qnos << eqn;
    auto eqn_str = qnos.str();
    source_ << s_off_ << "/* data for " << eqn << " */";
    source_ << s_off_++ << "namespace {\n";
    source_ << s_off_ << "::std::string const " << pfx << "TYPE_ID = \"" << eqn_str
            << "\";";
    source_ << s_off_ << "::std::uint64_t const " << pfx << "TYPE_ID_HASH = 0x"
            << ::std::hex << hash::murmur_hash(eqn_str) << ";";
    source_ << "\n" << --s_off_ << "} /* namespace for " << eqn << " */\n";
    source_ << s_off_ << "constexpr ::std::string const&" << s_off_;
    write_qualified_name(source_, eqn) << "::wire_static_type_id()" << s_off_++
            << "{";
    source_ << s_off_ << "return " << pfx << "TYPE_ID;";
    source_ << --s_off_ << "}\n";
    source_ << s_off_ << "constexpr ::std::uint64_t" << s_off_;
    write_qualified_name(source_, eqn) << "::wire_static_type_id_hash()"
            << s_off_++ << "{";
    source_ << s_off_ << "return " << pfx << "TYPE_ID_HASH;";
    source_ << --s_off_ << "}\n";

    current_scope_.components.push_back(elem->name());
    return eqn_str;
}

void
generator::generate_exception(ast::exception_ptr exc)
{
    adjust_scope(exc);

    static const qname root_exception {"::wire::errors::user_exception"};

    qname parent_name = exc->get_parent() ?
            exc->get_parent()->get_qualified_name() : root_exception;

    header_ << h_off_ << "class " << exc->name()
            << " : public ";
    write_qualified_name(header_, parent_name);
    header_ << " {";

    current_scope_.components.push_back(exc->name());
    scope_stack_.push_back(exc);

    if (!exc->get_types().empty()) {
        header_ << h_off_++ << "public:";
        for (auto t : exc->get_types()) {
            generate_type_decl(t);
        }
        --h_off_;
    }
    if (!exc->get_constants().empty()) {
        header_ << h_off_++ << "public:";
        for (auto c : exc->get_constants()) {
            generate_constant(c);
        }
        --h_off_;
    }

    auto const& data_members = exc->get_data_members();

    // Constructors
    header_ << h_off_++ << "public:";

    ::std::ostringstream members_init;
    if (!data_members.empty()) {
        for (auto dm : data_members) {
            members_init << ", " << dm->name() << "{}";
        }
    }

    //@{ Default constructor
    header_ << h_off_ << "/* default constructor, for use in factories */"
            << h_off_ << exc->name() << "() : ";
    write_qualified_name(header_, parent_name) << "{}"
            << members_init.str() << " {}";
    //@}

    header_ << h_off_ << "/* templated constructor to format a ::std::runtime_error message */"
            << h_off_ << "template < typename ... T >"
            << h_off_ << exc->name() << "(T const& ... args) : ";
    write_qualified_name(header_, parent_name) << "(args ...)"
            << members_init.str() << "{}";

    // TODO constructors with data members variations
    if (!data_members.empty()) {
        ::std::ostringstream args;
        ::std::ostringstream init;
        ::std::ostringstream msg;

        ::std::deque<::std::string> rest;
        for (auto dm : data_members) {
            rest.push_back(dm->name() + "{}");
        }
        for (auto p = data_members.begin(); p != data_members.end(); ++p) {
            if (p != data_members.begin()) {
                args << ", ";
                init << "," << (h_off_ + 1) << "  ";
                msg << ", ";
            }
            write_arg_type(args, (*p)->get_type()) << " " << (*p)->name() << "_";
            init << (*p)->name() << "{" << (*p)->name() << "_}";
            msg << (*p)->name() << "_";

            rest.pop_front();

            header_ << h_off_ << exc->name() << "(" << args.str() << ")";
            header_ << ++h_off_ << ": ";
            write_qualified_name(header_, parent_name)
                    << "(wire_static_type_id(), " << msg.str() << "), "
                    << h_off_ << "  " << init.str();
            for (auto const& r : rest) {
                header_ << "," << h_off_ << "  " << r;
            }
            header_ << " {}";
            --h_off_;
        }
    }
    --h_off_;

    if (!data_members.empty()) {
        header_ << h_off_++ << "public:";
        for (auto dm : data_members) {
            header_ << h_off_;
            write_type_name(header_, dm->get_type()) << " " << dm->name() << ";";
        }
        --h_off_;
    }

    header_ << h_off_++ << "public:";
    auto qn_str = generate_type_id_funcs(exc);
    {
        // Member functions

        header_ << h_off_ << "void"
                << h_off_ << "__wire_write(output_iterator o) override;";

        header_ << h_off_ << "void"
                << h_off_ << "__wire_read(input_iterator& begin, input_iterator end, "
                        "bool read_head = true) override;";
    }

    header_ << --h_off_ << "};\n";
    current_scope_.components.pop_back();

    header_ << h_off_ << "using " << exc->name() << "_ptr = ::std::shared_ptr<"
                << exc->name() << ">;"
            << h_off_ << "using " << exc->name() << "_weak_ptr = ::std::weak_ptr<"
                << exc->name() << ">;\n";

    // Source
    // generate io funcs in cpp
    //------------------------------------------------------------------------
    //  Wire write function for an exception
    //------------------------------------------------------------------------
    source_ << s_off_ << "void"
            << s_off_;
    write_qualified_name(source_, exc->get_qualified_name())
        << "::__wire_write(output_iterator o)"
        << s_off_ << "{";

    ++s_off_;

    source_ << s_off_ << "auto encaps = o.encapsulation();";

    ::std::string flags = "::wire::encoding::segment_header::none";
    if (!exc->get_parent()) {
        flags = "::wire::encoding::segment_header::last_segment";
    }
    ::std::string type_id_func = qn_str.size() > sizeof(::std::uint64_t) ?
            "wire_static_type_id_hash" : "wire_static_type_id";
    source_ << s_off_ << "encaps.start_segment(" << type_id_func << "(), " << flags << ");";

    if (!data_members.empty()) {
        source_ << s_off_ << "::wire::encoding::write(o";
        for (auto dm : data_members) {
            source_ << ", " << dm->name();
        }
        source_ << ");";
    }

    source_ << s_off_ << "encaps.end_segment();";

    if (exc->get_parent()) {
        source_ << s_off_ << parent_name << "::__wire_write(o);";
    }

    source_ << --s_off_ << "}\n";

    //------------------------------------------------------------------------
    //  Wire read function for an exception
    //------------------------------------------------------------------------
    source_ << s_off_ << "void"
            << s_off_;
    write_qualified_name(source_, exc->get_qualified_name())
        << "::__wire_read(input_iterator& begin, input_iterator end, "
                    "bool read_head)"
            << s_off_ << "{";
    ++s_off_;

    source_ << s_off_ << "auto encaps = begin.incoming_encapsulation();";
    source_ << s_off_++ << "if (read_head) {";
    source_ << s_off_ <<    "::wire::encoding::segment_header seg_head;"
            << s_off_ <<    "encaps.read_segment_header(begin, end, seg_head);";
    source_ << s_off_ << "__check_segment_header< " << exc->name() << " >(seg_head);";
    source_ << --s_off_ << "}\n";

    if (!data_members.empty()) {
        source_ << s_off_ << "::wire::encoding::read(begin, end";
        for (auto dm : data_members) {
            source_ << ", " << dm->name();
        }
        source_ << ");";
    }

    if (exc->get_parent()) {
        source_ << s_off_ << parent_name << "::__wire_read(begin, encaps.end(), true);";
    }

    source_ << --s_off_ << "}\n";

    pop_scope();
}

void
generator::generate_interface(ast::interface_ptr iface)
{
    adjust_scope(iface);

    static const qname root_interface {"::wire::core::object"};

    header_ << h_off_ << "class " << iface->name();

    auto const& ancestors = iface->get_ancestors();
    if (!ancestors.empty()) {
        header_ << ++h_off_ << ": ";
        for ( auto a = ancestors.begin(); a != ancestors.end(); ++a ) {
            if (a != ancestors.begin())
                header_ << "," << h_off_ << "  ";
            header_ << "public virtual ";
            write_qualified_name(header_, (*a)->get_qualified_name());
        }
        --h_off_;
    } else {
        header_ << " : public virtual " << root_interface;
    }
    header_ << " {";

    current_scope_.components.push_back(iface->name());
    scope_stack_.push_back(iface);

    if (!iface->get_types().empty()) {
        header_ << h_off_++ << "public:";
        for (auto t : iface->get_types()) {
            generate_type_decl(t);
        }
        --h_off_;
    }
    if (!iface->get_constants().empty()) {
        header_ << h_off_++ << "public:";
        for (auto c : iface->get_constants()) {
            generate_constant(c);
        }
        --h_off_;
    }
    {
        // Constructor
        header_ << h_off_ << "public:";
        header_ << ++h_off_ << iface->name() << "()";
        header_ << ++h_off_ << ": ";
        write_qualified_name(header_, root_interface) << "()";
        ast::interface_list anc;

        iface->collect_ancestors(anc, [](ast::entity_const_ptr){ return true; });

        for (auto a : anc) {
            header_ << "," << h_off_ << "  ";
            write_qualified_name(header_, a->get_qualified_name()) << "()";
        }

        header_ << " {}\n";
        h_off_ -= 2;
    }

    header_ << h_off_++ << "public:";
    auto qn_str = generate_type_id_funcs(iface);
    auto const& funcs = iface->get_functions();
    if (!funcs.empty()) {
        header_ << --h_off_ << "public:";
        ++h_off_;
        // Dispatch methods
        for (auto f : funcs) {
            generate_dispatch_function_member(f);
        }
        --h_off_;
    }

    header_ << --h_off_ << "};\n";
    current_scope_.components.pop_back();

    header_ << h_off_ << "using " << iface->name()
            << "_ptr = ::std::shared_ptr< " << iface->name() << ">;";
    header_ << h_off_ << "using " << iface->name()
            << "_weak_ptr = ::std::weak_ptr< " << iface->name() << ">;";

    header_ << h_off_ << "/** TODO Generate proxy object */";
    header_ << h_off_ << "using " << iface->name()
            << "_prx = ::std::shared_ptr< " << iface->name() << ">; // THIS IS A TEMPORARY FAKE";
    header_ << "\n";
    pop_scope();
}

}  /* namespace cpp */
}  /* namespace idl */
}  /* namespace wire */
