/*
 * lua_source_stream.cpp
 *
 *  Created on: Nov 23, 2017
 *      Author: zmij
 */

#include <wire/idl/generator.hpp>
#include <wire/idl/syntax_error.hpp>
#include <wire/wire2lua/lua_source_stream.hpp>

#include <iomanip>

namespace wire {
namespace idl {
namespace lua {

namespace {

::std::string const autogenerated =
R"~(------------------------------------------------------------------------------
-- THIS FILE IS AUTOGENERATED BY wire2lua PROGRAM
-- Any manual modifications can be lost
------------------------------------------------------------------------------
)~";

void
write_offset(::std::ostream& os, int space_number)
{
    if (space_number > 0)
        os << ::std::setw( space_number ) << ::std::setfill(' ') << " ";
}

}

source_stream::source_stream(::std::string const& filename)
    : stream_{filename},
      current_offset_{0},
      tab_width_{4}
{
    if (!stream_) {
        throw ::std::runtime_error("Failed to open output file " + filename);
    }
    stream_ << autogenerated;
}

void
source_stream::write_offset(int temp)
{
    stream_ << "\n";
    lua::write_offset(stream_, (current_offset_ + temp) * tab_width_);
}

void
source_stream::modify_offset(int delta)
{
    current_offset_ += delta;
    if (current_offset_ < 0)
        current_offset_ = 0;
}

void
source_stream::set_offset(int offset)
{
    current_offset_ = offset;
    if (current_offset_ < 0)
        current_offset_ = 0;
}

source_stream&
operator << (source_stream& os, mapped_type const& mt)
{
    if (auto pt = ast::dynamic_entity_cast< ast::parametrized_type >(mt.type)) {
        os << "wire.types." << pt->name();
        if (pt->name() == ast::VARIANT) {
            os << "({ ";
            for (auto const& p : pt->params()) {
                switch (p.which()) {
                    case ast::template_param_type::type:
                        os << mapped_type{ ::boost::get< ast::type_ptr >(p) } << ", ";
                        break;
                    default:
                        throw grammar_error(mt.type->decl_position(), "Unexpected variant parameter");
                }
            }
            os << "})";
        } else if (pt->name() == ast::DICTONARY) {
            // Expect exactly two type params
            os << "(";
            for (auto p = pt->params().begin(); p != pt->params().end(); ++p) {
                if (p != pt->params().begin())
                    os << ", ";
                switch (p->which()) {
                    case ast::template_param_type::type:
                        os << mapped_type{ ::boost::get< ast::type_ptr >(*p) };
                        break;
                    default:
                        throw grammar_error(mt.type->decl_position(), "Unexpected dictionary parameter");
                }
            }
            os << ")";
        } else if (pt->name() == ast::ARRAY) {
            // Expect exactly two params: type and int
            os << "(";
            for (auto p = pt->params().begin(); p != pt->params().end(); ++p) {
                if (p != pt->params().begin())
                    os << ", ";
                switch (p->which()) {
                    case ast::template_param_type::type:
                        os << mapped_type{ ::boost::get< ast::type_ptr >(*p) };
                        break;
                    case ast::template_param_type::integral:
                        os << ::boost::get< ::std::string >(*p);
                        break;
                    default:
                        throw grammar_error(mt.type->decl_position(), "Unexpected array parameter");
                }
            }
            os << ")";
        } else {
            os << "(";
            auto const& p = pt->params().front();
            switch (p.which()) {
                case ast::template_param_type::type:
                    os << mapped_type{ ::boost::get< ast::type_ptr >(p) };
                    break;
                default:
                    throw grammar_error(mt.type->decl_position(), "Unexpected " + pt->name() + " parameter");
            }
            os << ")";
        }
    } else if (auto ref = ast::dynamic_entity_cast< ast::reference >(mt.type)) {
        os << "wire.types.type('proxy')";
    } else {
        os << "wire.types.type('" << mt.type->get_qualified_name() << "')";
    }
    return os;
}


} /* namespace lua */
} /* namespace idl */
} /* namespace wire */

